apply plugin: 'maven-publish'

//需要注意的是，JitPack 默认要求代码库（Repository）是公开的（Public），否则依赖的项目无法依赖进去
// 试了一下，好像jitpack的版本号只于github的云端tag版本有关，和本地的无关，但最好是定一样的吧，因为这样好记忆一点

publishing {
    publications {
        release(MavenPublication) {
            // 使用gradle.properties中的同名字段是可以这样写，统一groupId
            // groupId = project.findProperty("groupId")

            // 直接获取内部group命名,空则用公共的
            groupId = group ?: project.findProperty("groupId")

            // 直接这样就可以拿到module的名称，比如freeDialogm,common,不包含目录的
            artifactId = project.name

            // 使用gradle.properties中的同名字段是可以这样写,统一版本
            // version = project.findProperty("version")

            // 获取外部module命名版本，(或者压根不写，直接在每个module下写version版本也可)
            version = getVersion() ?: project.findProperty("version")

            // artifact androidSourcesJar //不用这句，多余的

            // 获取源码aar上传，不仅仅是jar了
            afterEvaluate {
                artifact(tasks.getByName("bundleReleaseAar"))
            }
        }
    }
}

//增加上传远吗
//task androidSourcesJar(type: Jar) {
//    archiveClassifier.set('sources')
//    if (project.plugins.findPlugin("com.android.library")) {
//        from android.sourceSets.main.java.srcDirs
//    } else {
//        from sourceSets.main.java.srcDirs
//    }
//}


//检查你的库是否可以安装到 mavenLocal（$HOME/.m2/repository):

//        ./gradlew publishToMavenLocal
//        // or if you named your publication "release"
//         ./gradlew publishReleasePublicationToMavenLocal

//如果上一步一切顺利，你的库就可以发布了！


//总结：task这段可以不用，因为jitpack会自己处理的，
//以下这句很重要：决定了会不会上传aar,不上aar源码就不能正常引入到其他项目【它会只有jar和pom,不合理】，而上传aar后具备aar和jar都有。
//afterEvaluate {
//    artifact(tasks.getByName("bundleReleaseAar"))
//}

//另外还有：groupId最好是：com.github.ChenBabys【这样好像成功率都高了】,   artifactId则直接拿子包名，

//还有一点需要注意:如果远端库是公开的，那么就要提交代码到公开库之后再新建release和tag,意思就是提交前，远端库得是公开的，再新建release和tag，然后再去jitpack 公开库处点击git it ，否则也会down不下来的